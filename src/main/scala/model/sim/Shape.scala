package model.sim

import java.io.{ByteArrayInputStream, InputStream}
import java.util.UUID

import javax.imageio.ImageIO
import model.sim.Shape.Metadata
import model.{Position, Positioned}

import scala.collection.mutable

sealed trait Shape

sealed trait Element extends Shape

object Shape        {
  type Metadata = mutable.Map[String, String]
}

// Assume all parameters are the default generated by JSimGraph, we'll add parameters next week
sealed abstract class Node                        extends Element with Positioned {
  var position: Position
  var name: String
  var metadata: Metadata
  val uid: UUID = UUID.randomUUID()

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }
  override def hashCode: Int             = uid.hashCode
}

case class Source(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Queue(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Sink(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Fork(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Join(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Connection(source: Node, target: Node) extends Element

case class Trace(
    var image: Trace.Image,
    var position: Position,
    var width: Double,
    var height: Double
) extends Shape
    with Positioned {
  def end: Position = position + Position(width, height)
  val uid: UUID     = UUID.randomUUID()

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }
  override def hashCode: Int             = uid.hashCode
}

object Trace        {
  /* Use a byte array for redrawing in memory, especially since a FileInputStream cannot be reset.
     A better buffer system may be warranted later, but we can keep the interface consistent and provide a stream
     as necessary */
  class Image(raw: InputStream) {
    private val bytes = raw.readAllBytes()
    private val image = ImageIO.read(stream)

    def stream: InputStream = { new ByteArrayInputStream(bytes) }

    override def equals(obj: Any): Boolean =
      obj match { case t: Image => eq(t); case _ => false }

    def height: Int = image.getHeight
    def width: Int  = image.getWidth
  }

  object Image                  {
    def apply(raw: InputStream): Image = new Image(raw)

    def unapply(image: Image): Option[InputStream] = Some(image.stream)
  }
}
