package model.sim

import java.io.{ByteArrayInputStream, InputStream}
import java.util.UUID

import javax.imageio.ImageIO
import model.sim.DropStrategy.{DropStrategy, Value}
import model.{Position, Positioned, sim}

import scala.collection.mutable

sealed trait Shape

sealed trait Element extends Shape

// Assume all parameters are the default generated by JSimGraph, we'll add parameters next week
case class Node(
    var name: String,
    var position: Position,
    nodeType: NodeType,
    var rotated: Boolean = false,
    uid: UUID = UUID.randomUUID()
) extends Element
    with Positioned {

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }

  override def hashCode: Int = uid.hashCode
}

sealed trait NodeType

case class Source(
    sourceSection: SourceSection,
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Sink(sinkSection: SinkSection) extends NodeType

case class Terminal(
    terminalSection: UnimplementedSection[TerminalSection],
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Router(
    queueSection: QueueSection,
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Delay(
    queueSection: QueueSection,
    delaySection: UnimplementedSection[DelaySection],
    routerSection: RouterSection
) extends NodeType

//This is what you'd intuitively call a queue
case class Server(
    queueSection: QueueSection,
    serverSection: UnimplementedSection[ServerSection],
    routerSection: RouterSection
) extends NodeType

case class Fork(
    queueSection: QueueSection,
    tunnelSection: TunnelSection,
    forkSection: ForkSection
) extends NodeType

case class Join(
    joinSection: JoinSection,
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Logger(
    queueSection: QueueSection,
    loggerSection: UnimplementedSection[LoggerSection],
    routerSection: RouterSection
) extends NodeType

case class ClassSwitch(
    queueSection: QueueSection,
    classSwitch: UnimplementedSection[ClassSwitchSection],
    routerSection: RouterSection
) extends NodeType

case class Semaphore(
    semaphoreSection: UnimplementedSection[SemaphoreSection],
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Scalar(
    joinSection: JoinSection,
    tunnelSection: TunnelSection,
    forkSection: ForkSection
) extends NodeType

case class Place(
    storageSection: UnimplementedSection[StorageSection],
    tunnelSection: TunnelSection,
    linkageSection: UnimplementedSection[LinkageSection]
) extends NodeType

case class Transition(
    enablingSection: UnimplementedSection[EnablingSection],
    timingSection: UnimplementedSection[TimingSection],
    firingSection: UnimplementedSection[FiringSection]
) extends NodeType

case class Unimplemented(sections: Seq[UnimplementedSection[_ <: TypeSection]])
    extends NodeType

// Sections make up a NodeType
sealed trait TypeSection

/* These refClasses are the userClasses for which this section's node is
 * the reference node.
 */
case class SourceSection(refClassNames: Seq[String])    extends TypeSection
case class TunnelSection()                              extends TypeSection
case class RouterSection(var routingStrategy: RoutingStrategy)
    extends TypeSection
case class SinkSection()                                extends TypeSection
case class TerminalSection()                            extends TypeSection
case class QueueSection(
    var size: Option[Int],
    var dropStrategy: Option[DropStrategy],
    queueingStrategy: Seq[xml.Node]
) extends TypeSection
case class DelaySection()                               extends TypeSection
case class ServerSection()                              extends TypeSection
case class ForkSection(
    var jobsPerLink: Int,
    var isSimplifiedFork: Boolean,
    forkStrategy: Seq[xml.Node]
) extends TypeSection
case class JoinSection(joinStrategies: mutable.Map[String, JoinStrategy])
    extends TypeSection
case class LoggerSection()                              extends TypeSection
case class ClassSwitchSection()                         extends TypeSection
case class SemaphoreSection()                           extends TypeSection
case class StorageSection()                             extends TypeSection
case class LinkageSection()                             extends TypeSection
case class EnablingSection()                            extends TypeSection
case class TimingSection()                              extends TypeSection
case class FiringSection()                              extends TypeSection
case class UnimplementedSection[T <: TypeSection](raw: xml.Node)
    extends TypeSection     {
  def asImplementedUnsafe: T = ???
}

object DropStrategy                                     extends Enumeration {
  type DropStrategy = Value

  val DROP: sim.DropStrategy.Value          = Value("drop")
  val WAITING_QUEUE: sim.DropStrategy.Value = Value("waiting queue")
  val BAS_BLOCKING: sim.DropStrategy.Value  = Value("BAS blocking")

}

sealed trait JoinStrategy

case class StandardJoin()                               extends JoinStrategy {
  override def toString: String = "Standard Join"
}
case class Quorum(numRequired: Int)                     extends JoinStrategy {
  override def toString: String = "Quorum"
}
case class Guard(guardValues: mutable.Map[String, Int]) extends JoinStrategy {
  override def toString: String = "Guard"
}

sealed trait RoutingStrategy

case class Random()                                     extends RoutingStrategy {
  override def toString: String = "Random"
}
case class RoundRobin()                                 extends RoutingStrategy {
  override def toString: String = "Round Robin"
}
case class Probabilities(probabilities: mutable.Map[Node, Double])
    extends RoutingStrategy {
  override def toString: String = "Probabilities"
}
case class JSQ()                                        extends RoutingStrategy {
  override def toString: String = "Join the Shortest Queue (JSQ)"
}
case class SRT()                                        extends RoutingStrategy {
  override def toString: String = "Shortest Response Time"
}
case class LeastUtilisation()                           extends RoutingStrategy {
  override def toString: String = "Least Utilisation"
}
case class FastestService()                             extends RoutingStrategy {
  override def toString: String = "Fastest Service"
}
case class LoadDependentRouting(raw: xml.Node)          extends RoutingStrategy {
  override def toString: String = "Load Dependent Routing"
}
case class PowerOfK(var k: Int = 1, var hasMemory: Boolean = false)
    extends RoutingStrategy {
  override def toString: String = "Power of k"
}
case class WeightedRoundRobin(probabilities: mutable.Map[Node, Int])
    extends RoutingStrategy {
  override def toString: String = "Weighted Round Robin"
}
case class Disabled()                                   extends RoutingStrategy {
  override def toString: String = "Disabled"
}
case class UnimplementedRoutingStrategy(raw: xml.Node)
    extends RoutingStrategy {}

case class Connection(source: Node, target: Node)       extends Element

case class Trace(
    var image: Trace.Image,
    var position: Position,
    var width: Double,
    var height: Double
) extends Shape
    with Positioned {
  def end: Position = position + Position(width, height)
  val uid: UUID     = UUID.randomUUID()

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }
  override def hashCode: Int             = uid.hashCode
}

object Trace        {
  /* Use a byte array for redrawing in memory, especially since a FileInputStream cannot be reset.
     A better buffer system may be warranted later, but we can keep the interface consistent and provide a stream
     as necessary */
  class Image(raw: InputStream) {
    private val bytes = raw.readAllBytes()
    private val image = ImageIO.read(stream)

    def stream: InputStream = { new ByteArrayInputStream(bytes) }

    override def equals(obj: Any): Boolean =
      obj match { case t: Image => eq(t); case _ => false }

    def height: Int = image.getHeight
    def width: Int  = image.getWidth
  }

  object Image                  {
    def apply(raw: InputStream): Image = new Image(raw)

    def unapply(image: Image): Option[InputStream] = Some(image.stream)
  }
}
