package model.sim

import java.io.{ByteArrayInputStream, InputStream}
import java.util.UUID

import model.sim.Shape.Metadata
import model.{Position, Positioned}

import scala.collection.mutable

sealed trait Shape

sealed trait Element extends Shape

object Shape        {
  type Metadata = mutable.Map[String, String]
}

// Assume all parameters are the default generated by JSimGraph, we'll add parameters next week
sealed abstract class Node                        extends Element with Positioned {
  var position: Position
  var name: String
  var metadata: Metadata
  val uid: UUID = UUID.randomUUID()

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }
  override def hashCode: Int             = uid.hashCode
}

case class BlockingQueue(
    var metadata: Metadata,
    var name: String,
    var position: Position,
    //Specifics
    var classDrop: Array[Boolean],
    var classWeights: Array[Double]
) extends Node

case class BlockingRouter(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class ClassSwitch(
    var metadata: Metadata,
    var name: String,
    var position: Position,
    //Specifics
    var matrix: Array[Array[Float]]
) extends Node

case class Delay(
    var metadata: Metadata,
    var name: String,
    var position: Position,
    //Specifics
    var coolStart: Boolean
//    var serviceStrategies: Array[ServiceStrategy]
) extends Node

case class Enabling(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
//    var enablingConditions: Array[TransitionMatrix],
//    var inhibitingConditions: Array[TransitionMatrix]
) extends Node

case class Firing(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
//    var firingOutcomes: Array[TransitionMatrix]
) extends Node

case class Fork(
    var metadata: Metadata,
    var name: String,
    var position: Position,
    //Specifics
    var block: Int,
    var jobsPerLink: Int,
    var isSimplifiedFork: Boolean
    //    var forkStrategies: Array[ForkStrategy]
) extends Node

case class InputSection(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class JobSink(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Join(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Linkage(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class LogTunnel(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class OutputSection(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class PSServer(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class PipeSection(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Queue(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

//case class RandomSource(
//    var metadata: Metadata,
//    var name: String,
//    var position: Position
//    //Specifics
//) extends Node

case class Router(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Semaphore(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Server(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class ServiceSection(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class ServiceTunnel(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Storage(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Terminal(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Timing(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

//TODO: This is should be RandomSource as JMT has no 'Source' node
case class Source(
    var metadata: Metadata,
    var name: String,
    var position: Position
    //Specifics
) extends Node

case class Connection(source: Node, target: Node) extends Element

case class Trace(
    var image: Trace.Image,
    var position: Position,
    var height: Int,
    var width: Int
) extends Shape
    with Positioned {
  def end: Position = position + Position(height, width)
  val uid: UUID     = UUID.randomUUID()

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }
  override def hashCode: Int             = uid.hashCode
}

object Trace        {
  /* Use a byte array for redrawing in memory, especially since a FileInputStream cannot be reset.
     A better buffer system may be warranted later, but we can keep the interface consistent and provide a stream
     as necessary */
  class Image(raw: InputStream) {
    private val bytes       = raw.readAllBytes()
    def stream: InputStream = { new ByteArrayInputStream(bytes) }

    override def equals(obj: Any): Boolean =
      obj match { case t: Image => eq(t); case _ => false }
  }

  object Image                  {
    def apply(raw: InputStream): Image = new Image(raw)

    def unapply(image: Image): Option[InputStream] = Some(image.stream)
  }
}
