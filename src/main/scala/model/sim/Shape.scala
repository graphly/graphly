package model.sim

import java.io.{ByteArrayInputStream, InputStream}

import model.sim.Shape.Metadata
import model.{Position, Positioned}

import scala.collection.mutable

sealed trait Shape

sealed trait Element extends Shape

object Shape        {
  type Metadata = mutable.Map[String, String]
}

// Assume all parameters are the default generated by JSimGraph, we'll add parameters next week
sealed trait Node extends Element with Positioned {
  var position: Position
  var name: String
  var metadata: Metadata
}

case class Source(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Queue(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Sink(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Fork(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Join(
    var metadata: Metadata,
    var name: String,
    var position: Position
) extends Node

case class Connection(source: Node, target: Node) extends Element

case class Trace(
    var image: Trace.Image,
    var position: Position,
    var height: Int,
    var width: Int
) extends Shape
    with Positioned {
  def end: Position = position + Position(height, width)
}

object Trace        {
  /* Use a byte array for redrawing in memory, especially since a FileInputStream cannot be reset.
     A better buffer system may be warranted later, but we can keep the interface consistent and provide a stream
     as necessary */
  class Image(raw: InputStream) {
    private val bytes       = raw.readAllBytes()
    def stream: InputStream = { new ByteArrayInputStream(bytes) }

    override def equals(obj: Any): Boolean =
      obj match { case t: Image => eq(t); case _ => false }
  }

  object Image                  {
    def apply(raw: InputStream): Image = new Image(raw)

    def unapply(image: Image): Option[InputStream] = Some(image.stream)
  }
}
