package model.sim

import java.io.{ByteArrayInputStream, InputStream}

import model.{Position, Positioned}

sealed trait Shape

sealed trait Element extends Shape

// Assume all parameters are the default generated by JSimGraph, we'll add parameters next week
sealed trait Node                         extends Element with Positioned {
  var position: Position
}
case class Source(var position: Position) extends Node
case class Queue(var position: Position)  extends Node
case class Sink(var position: Position)   extends Node
case class Fork(var position: Position)   extends Node
case class Join(var position: Position)   extends Node

case class Connection(source: Node, target: Node) extends Element

case class Trace(
    var image: Trace.Image,
    var position: Position,
    var height: Int,
    var width: Int
) extends Shape
    with Positioned {
  def end: Position = position + Position(height, width)
}

object Trace        {
  /* Use a byte array for redrawing in memory, especially since a FileInputStream cannot be reset.
     A better buffer system may be warranted later, but we can keep the interface consistent and provide a stream
     as necessary */
  class Image(raw: InputStream) {
    private val bytes       = raw.readAllBytes()
    def stream: InputStream = { new ByteArrayInputStream(bytes) }

    override def equals(obj: Any): Boolean =
      obj match { case t: Trace => eq(t); case _ => false }
  }

  object Image                  {
    def apply(raw: InputStream): Image = new Image(raw)

    def unapply(image: Image): Option[InputStream] = Some(image.stream)
  }
}
