package model.sim

import java.io.{ByteArrayInputStream, InputStream}
import java.util.UUID

import javax.imageio.ImageIO
import model.sim.DropStrategy.{DropStrategy, Value}
import model.{Position, Positioned, sim}

sealed trait Shape

sealed trait Element extends Shape

// Assume all parameters are the default generated by JSimGraph, we'll add parameters next week
case class Node(
    var name: String,
    var position: Position,
    nodeType: NodeType,
    var rotated: Boolean = false,
    uid: UUID = UUID.randomUUID()
) extends Element
    with Positioned {

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }

  override def hashCode: Int = uid.hashCode
}

sealed trait NodeType

case class Source(
    sourceSection: SourceSection,
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Sink(sinkSection: SinkSection) extends NodeType

case class Terminal(
    terminalSection: UnimplementedSection[TerminalSection],
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Router(
    queueSection: QueueSection,
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Delay(
    queueSection: QueueSection,
    delaySection: UnimplementedSection[DelaySection],
    routerSection: RouterSection
) extends NodeType

//This is what you'd intuitively call a queue
case class Server(
    queueSection: QueueSection,
    serverSection: UnimplementedSection[ServerSection],
    routerSection: RouterSection
) extends NodeType

case class Fork(
    queueSection: QueueSection,
    tunnelSection: TunnelSection,
    forkSection: UnimplementedSection[ForkSection]
) extends NodeType

case class Join(
    joinSection: UnimplementedSection[JoinSection],
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Logger(
    queueSection: QueueSection,
    loggerSection: UnimplementedSection[LoggerSection],
    routerSection: RouterSection
) extends NodeType

case class ClassSwitch(
    queueSection: QueueSection,
    classSwitch: UnimplementedSection[ClassSwitchSection],
    routerSection: RouterSection
) extends NodeType

case class Semaphore(
    semaphoreSection: UnimplementedSection[SemaphoreSection],
    tunnelSection: TunnelSection,
    routerSection: RouterSection
) extends NodeType

case class Scalar(
    joinSection: UnimplementedSection[JoinSection],
    tunnelSection: TunnelSection,
    forkSection: UnimplementedSection[ForkSection]
) extends NodeType

case class Place(
    storageSection: UnimplementedSection[StorageSection],
    tunnelSection: TunnelSection,
    linkageSection: UnimplementedSection[LinkageSection]
) extends NodeType

case class Transition(
    enablingSection: UnimplementedSection[EnablingSection],
    timingSection: UnimplementedSection[TimingSection],
    firingSection: UnimplementedSection[FiringSection]
) extends NodeType

case class Unimplemented(sections: Seq[UnimplementedSection[_ <: TypeSection]])
    extends NodeType

// Sections make up a NodeType
sealed trait TypeSection

/* These refClasses are the userClasses for which this section's node is
 * the reference node.
 */
case class SourceSection(refClassNames: Seq[String]) extends TypeSection
case class TunnelSection()                           extends TypeSection
case class RouterSection(routingStrategy: xml.Node)  extends TypeSection
case class SinkSection()                             extends TypeSection
case class TerminalSection()                         extends TypeSection
case class QueueSection(
    size: Option[Int],
    dropStrategy: Option[DropStrategy],
    queueingStrategy: Seq[xml.Node]
) extends TypeSection
case class DelaySection()                            extends TypeSection
case class ServerSection()                           extends TypeSection
case class ForkSection()                             extends TypeSection
case class JoinSection()                             extends TypeSection
case class LoggerSection()                           extends TypeSection
case class ClassSwitchSection()                      extends TypeSection
case class SemaphoreSection()                        extends TypeSection
case class StorageSection()                          extends TypeSection
case class LinkageSection()                          extends TypeSection
case class EnablingSection()                         extends TypeSection
case class TimingSection()                           extends TypeSection
case class FiringSection()                           extends TypeSection
case class UnimplementedSection[T <: TypeSection](raw: xml.Node)
    extends TypeSection {
  def asImplementedUnsafe: T = ???
}

object DropStrategy                                  extends Enumeration {
  type DropStrategy = Value

  val DROP: sim.DropStrategy.Value          = Value("drop")
  val WAITING_QUEUE: sim.DropStrategy.Value = Value("waiting queue")
  val BAS_BLOCKING: sim.DropStrategy.Value  = Value("BAS blocking")

//  override def toString(): String = this.Value.toString
}

case class Connection(source: Node, target: Node)    extends Element

case class Trace(
    var image: Trace.Image,
    var position: Position,
    var width: Double,
    var height: Double
) extends Shape
    with Positioned     {
  def end: Position = position + Position(width, height)
  val uid: UUID     = UUID.randomUUID()

  override def equals(obj: Any): Boolean =
    obj match {
      case node: Node => uid == node.uid
      case _ => false
    }
  override def hashCode: Int             = uid.hashCode
}

object Trace            {
  /* Use a byte array for redrawing in memory, especially since a FileInputStream cannot be reset.
     A better buffer system may be warranted later, but we can keep the interface consistent and provide a stream
     as necessary */
  class Image(raw: InputStream) {
    private val bytes = raw.readAllBytes()
    private val image = ImageIO.read(stream)

    def stream: InputStream = { new ByteArrayInputStream(bytes) }

    override def equals(obj: Any): Boolean =
      obj match { case t: Image => eq(t); case _ => false }

    def height: Int = image.getHeight
    def width: Int  = image.getWidth
  }

  object Image                  {
    def apply(raw: InputStream): Image = new Image(raw)

    def unapply(image: Image): Option[InputStream] = Some(image.stream)
  }
}
